#include "DataTable.h"
#include <boost/filesystem.hpp>


using namespace std;
using namespace cv;

namespace vs
{
    DataTable::DataTable(std::string dataPath):dataPath_(dataPath)
    {
        //load();
    }
    DataTable::~DataTable()
    {
        //save();
    }
    DataTable::DataTable(const DataTable & other)
    {
        this->dataPath_ = other.dataPath_;        
        for (size_t i = 0; i != other.deletedFlags_.size(); ++i)
        {
            if (other.deletedFlags_[i] == false)
            {
                insertVideo(other.videoNames_[i],other.keyFrames_[i],other.frameFeats_[i],
                            other.frameKeyPoints_[i],other.frameDescriptors_[i],other.descIndex_[i]);
            }
        }
    }

    DataTable & DataTable::operator=(DataTable & other)
    {
        this->swap(other);
        return *this;
    }
    void DataTable::swap(DataTable &other)
    {
        std::lock_guard<std::mutex> lg(mutex_);
        this->dataPath_.swap(other.dataPath_);
        this->deletedFlags_.swap(other.deletedFlags_);
        this->videoNames_.swap(other.videoNames_);
        this->vn2vid_.swap(other.vn2vid_);
        this->keyFrames_.swap(other.keyFrames_);
        this->frameFeats_.swap(other.frameFeats_);
        this->frameKeyPoints_.swap(other.frameKeyPoints_);
        this->frameDescriptors_.swap(other.frameDescriptors_);
        this->descIndex_.swap(other.descIndex_);
        this->frameCnts_.swap(other.frameCnts_);
        this->globalFmInd2Vid_.swap(other.globalFmInd2Vid_);
        this->globalFmInd2LocalFmInd_.swap(other.globalFmInd2LocalFmInd_);    
        isChanged = true;
    }


    int DataTable::insertVideo(const string videoName, const shared_ptr<vector<KeyFrame>> kfm,
                     const shared_ptr<Mat> feat, const shared_ptr<vector<vector<KeyPoint>>> keypoints,
                     const shared_ptr<vector<Mat>> desc, const shared_ptr<DescIndex> descIndex)
    {
        std::lock_guard<std::mutex> lg(mutex_);
        //already exist 
        if (vn2vid_.find(videoName) != vn2vid_.end())
            return -1;

        videoNames_.push_back(videoName);
        deletedFlags_.push_back(false);
        vn2vid_[videoName]=videoNames_.size()-1;
        keyFrames_.push_back(kfm);
        frameFeats_.push_back(feat);
        frameKeyPoints_.push_back(keypoints);
        frameDescriptors_.push_back(desc);
        descIndex_.push_back(descIndex);

        frameCnts_.push_back(feat->rows);
        globalFmInd2Vid_.insert(globalFmInd2Vid_.end(), feat->rows, videoNames_.size() - 1);
        std::vector<int> temp(feat->rows);
        std::iota(temp.begin(), temp.end(), 0);
        globalFmInd2LocalFmInd_.insert(globalFmInd2LocalFmInd_.end(), temp.begin(), temp.end());

        isChanged = true;
        return 0;
    }

    void DataTable::deleteVideo(std::string videoName)
    {
        std::lock_guard<std::mutex> lg(mutex_);
        auto iter = vn2vid_.find(videoName);
        if (iter == vn2vid_.end())
            return;
        size_t vid = iter->second;
        deletedFlags_[vid] = true;
        vn2vid_.erase(videoName);
        frameFeats_[vid] = nullptr;

        int deletedNum = std::count_if(deletedFlags_.begin(), deletedFlags_.end(), [](bool v){return v == true; });
        if (deletedNum > videoNames_.size() / 3.0f)
        {
            DataTable temp(*this);
            *this = temp;
            //DataTable temp;
            //temp.swap(*this);
        }
        isChanged = true;
    }

    void DataTable::save()
    {
        if (!isChanged)
            return;
        boost::filesystem::path p(dataPath_);
        create_directories(p);

        shared_ptr<FILE> file(fopen(string(dataPath_+"/dataTable.dat").c_str(), "wb"),fclose);

        int n = this->size();
        fwrite(&n,sizeof(n),1, file.get());
        for (size_t i = 0; i != deletedFlags_.size(); ++i)
        {
            if (deletedFlags_[i] == true)
                continue;
            //save video names, vn2vid_ construct automatically 
            n = videoNames_[i].size();
            fwrite(&n, sizeof(n), 1, file.get());
            fwrite(videoNames_[i].c_str(), 1, videoNames_[i].size(), file.get());
            //key frame indices
            n = keyFrames_[i]->size();
            fwrite(&n, sizeof(n), 1, file.get());
            for (auto &value : *keyFrames_[i].get())
            {
                fwrite(&value.key_fmIndex_, sizeof(value.key_fmIndex_), 1, file.get());
                fwrite(&value.start_index_, sizeof(value.start_index_), 1, file.get());
                fwrite(&value.end_index_, sizeof(value.end_index_), 1, file.get());
            }
            //frame global feat
            int r, c, t, s;
            r = frameFeats_[i]->rows;
            c = frameFeats_[i]->cols;
            t = frameFeats_[i]->type();
            s = frameFeats_[i]->elemSize();
            
            fwrite(&r, sizeof(r), 1, file.get());
            fwrite(&c, sizeof(r), 1, file.get());
            fwrite(&t, sizeof(t), 1, file.get());
            //fwrite(&s, sizeof(s), 1, file.get());

            fwrite(frameFeats_[i]->data, frameFeats_[i]->elemSize(), frameFeats_[i]->total(),file.get());
            //key points
            n = frameKeyPoints_[i]->size();
            fwrite(&n, sizeof(n), 1, file.get());
            for (auto &vec_kp : *frameKeyPoints_[i].get())
            {
                n = vec_kp.size();
                fwrite(&n, sizeof(n), 1, file.get());
                for (auto &kp : vec_kp)
                {
                    fwrite(&kp.pt.x, sizeof(kp.pt.x), 1, file.get()); 
                    fwrite(&kp.pt.y, sizeof(kp.pt.y), 1, file.get());
                    fwrite(&kp.size, sizeof(kp.size), 1, file.get());
                    fwrite(&kp.angle, sizeof(kp.angle), 1, file.get());
                    fwrite(&kp.response, sizeof(kp.response), 1, file.get());
                    fwrite(&kp.octave, sizeof(kp.octave), 1, file.get());
                    fwrite(&kp.class_id, sizeof(kp.class_id), 1, file.get());
                }
            }
            // descriptors
            n = frameDescriptors_[i]->size();
            fwrite(&n, sizeof(n), 1, file.get());
            for (auto &mat : *frameDescriptors_[i].get())
            {
                r = mat.rows;
                c = mat.cols;
                t = mat.type();
                fwrite(&r, sizeof(r), 1, file.get());
                fwrite(&c, sizeof(r), 1, file.get());
                fwrite(&t, sizeof(t), 1, file.get());
                fwrite(mat.data, mat.elemSize(), mat.total(), file.get());
            }

        }

        isChanged = false;
    }

    int DataTable::load()
    {
        boost::filesystem::path p(dataPath_);
        if (!exists(p) || !is_directory(p))
            return -1;

        FILE *file = fopen(string(dataPath_ + "/dataTable.dat").c_str(), "rb");

        if (file == NULL)
            return -1;

        int videoNum;
        fread(&videoNum, sizeof(videoNum), 1, file);

        char buf[PATH_BUF_SIZE] = { 0 };
        int n;
        for (int i = 0; i != videoNum; ++i)
        {
            //video name
            fread(&n, sizeof(n), 1, file);
            fread(buf, 1, n, file);
            string videoName(buf);
            memset(buf, 0, PATH_BUF_SIZE);

            //key frame index
            shared_ptr<vector<KeyFrame>> kfm(new vector<KeyFrame>);
            fread(&n, sizeof(n), 1, file);
            kfm->resize(n);
            for (auto &value : *kfm.get())
            {
                fread(&value.key_fmIndex_, sizeof(value.key_fmIndex_), 1, file);
                fread(&value.start_index_, sizeof(value.start_index_), 1, file);
                fread(&value.end_index_, sizeof(value.end_index_), 1, file);
            }

            //frame global feat
            int r, c, t;
            fread(&r, sizeof(r), 1, file);
            fread(&c, sizeof(c), 1, file);
            fread(&t, sizeof(t), 1, file);

            shared_ptr<Mat> feat(new Mat(r, c, t));
            fread(feat->data, feat->elemSize(), feat->total(), file);

            //key points 
            shared_ptr<vector<vector<KeyPoint>>> keys(new vector<vector<KeyPoint>>);
            fread(&n, sizeof(n), 1, file);
            keys->resize(n);
            for (auto &vec_kp : *keys.get())
            {
                fread(&n, sizeof(n), 1, file);
                vec_kp.resize(n);
                for (auto &kp : vec_kp)
                {
                    fread(&kp.pt.x, sizeof(kp.pt.x), 1, file);
                    fread(&kp.pt.y, sizeof(kp.pt.y), 1, file);
                    fread(&kp.size, sizeof(kp.size), 1, file);
                    fread(&kp.angle, sizeof(kp.angle), 1, file);
                    fread(&kp.response, sizeof(kp.response), 1, file);
                    fread(&kp.octave, sizeof(kp.octave), 1, file);
                    fread(&kp.class_id, sizeof(kp.class_id), 1, file);
                }
            }
            //descirptors
            shared_ptr<vector<Mat>> desc(new vector<Mat>);
            fread(&n, sizeof(n), 1, file);
            desc->resize(n);
            for (auto &mat : *desc.get())
            {
                fread(&r, sizeof(r), 1, file);
                fread(&c, sizeof(c), 1, file);
                fread(&t, sizeof(t), 1, file);
                //fread(&s, sizeof(s), 1, file);
                mat = Mat(r, c, t);
                fread(mat.data, mat.elemSize(), mat.total(), file);
            }

            this->insertVideo(videoName, kfm, feat, keys, desc, NULL);
        }//end for

        fclose(file);
        isChanged = false;  //insertVideo will set this value to true
        return 0;
    }
    int DataTable::gFmInd2Vid(int gFmInd)
    {
        std::lock_guard<std::mutex> lg(mutex_);
        return this->globalFmInd2Vid_[gFmInd];
    }

    int DataTable::gFmInd2LFmInd(int gFmInd)
    {
        std::lock_guard<std::mutex> lg(mutex_);
        return this->globalFmInd2LocalFmInd_[gFmInd];
    }

    vector<vector<KeyPoint>> & DataTable::getVideoKeyPoints(int vid)
    {
        return *frameKeyPoints_[vid].get();       
    }
    vector<Mat> & DataTable::getVideoDesc(int vid)
    {
        return *frameDescriptors_[vid].get();
    }

    int DataTable::getVideoFmCnt(int vid)
    {
        return frameCnts_[vid];
    }

    std::vector<std::shared_ptr<cv::Mat>>& DataTable::getVideoFrameFeat()
    {
        return frameFeats_;
    }
    std::vector<KeyFrame>& DataTable::getVideoKeyFrames(int vid)
    {
        return *keyFrames_[vid];
    }

}